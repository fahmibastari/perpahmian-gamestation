<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tetris - Classic Puzzle</title>
    <link rel="stylesheet" href="shared-styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        .tetris-wrapper {
            display: flex;
            gap: var(--spacing-xl);
            justify-content: center;
            align-items: flex-start;
            flex-wrap: wrap;
            max-width: 900px;
            margin: 0 auto;
        }

        .game-canvas {
            border: 3px solid rgba(168, 85, 247, 0.5);
            border-radius: var(--radius-lg);
            box-shadow: 0 0 40px rgba(168, 85, 247, 0.3);
            background: #000;
        }

        .side-panel {
            display: flex;
            flex-direction: column;
            gap: var(--spacing-lg);
        }

        .panel-box {
            background: rgba(20, 20, 30, 0.8);
            border: 2px solid rgba(168, 85, 247, 0.3);
            border-radius: var(--radius-lg);
            padding: var(--spacing-lg);
            backdrop-filter: blur(10px);
        }

        .panel-title {
            font-size: 0.9rem;
            color: rgba(255, 255, 255, 0.7);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: var(--spacing-sm);
        }

        .preview-canvas {
            border: 2px solid rgba(168, 85, 247, 0.2);
            border-radius: var(--radius-md);
            background: #000;
            display: block;
            margin: 0 auto;
        }

        .controls-hint {
            font-size: 0.85rem;
            color: rgba(255, 255, 255, 0.6);
            line-height: 1.6;
        }

        .controls-hint strong {
            color: var(--color-purple-400);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-header">
            <a href="../index.html" class="back-btn"><span>←</span><span>Back to Home</span></a>
            <h1 class="game-title">Tetris</h1>
            <div></div>
        </div>

        <div class="game-stats">
            <div class="stat-item"><div class="stat-label">Score</div><div class="stat-value" id="score">0</div></div>
            <div class="stat-item"><div class="stat-label">Lines</div><div class="stat-value" id="lines">0</div></div>
            <div class="stat-item"><div class="stat-label">Level</div><div class="stat-value" id="level">1</div></div>
        </div>

        <div class="instructions">
            <h3>Classic Tetris</h3>
            <p>Stack blocks to clear lines. Complete rows disappear. Don't let blocks reach the top!</p>
        </div>

        <div class="tetris-wrapper">
            <div class="side-panel">
                <div class="panel-box">
                    <div class="panel-title">Next Piece</div>
                    <canvas id="nextCanvas" class="preview-canvas" width="120" height="120"></canvas>
                </div>
                <div class="panel-box">
                    <div class="panel-title">Hold Piece</div>
                    <canvas id="holdCanvas" class="preview-canvas" width="120" height="120"></canvas>
                </div>
            </div>

            <canvas id="gameCanvas" class="game-canvas" width="300" height="600"></canvas>

            <div class="side-panel">
                <div class="panel-box">
                    <div class="panel-title">Controls</div>
                    <div class="controls-hint">
                        <strong>←→</strong> Move<br>
                        <strong>↓</strong> Soft Drop<br>
                        <strong>↑</strong> Rotate<br>
                        <strong>SPACE</strong> Hard Drop<br>
                        <strong>C</strong> Hold Piece<br>
                        <strong>P</strong> Pause
                    </div>
                </div>
            </div>
        </div>

        <div class="game-controls" style="margin-top: var(--spacing-xl);">
            <button class="btn btn-primary" id="startBtn" onclick="startGame()">Start Game</button>
        </div>
    </div>

    <div class="modal" id="gameOverModal">
        <div class="modal-content">
            <h2 class="modal-title">Game Over!</h2>
            <p class="modal-text">Final Score: <span id="finalScore">0</span></p>
            <p class="modal-text">Lines Cleared: <span id="finalLines">0</span></p>
            <p class="modal-text">Level Reached: <span id="finalLevel">1</span></p>
            <button class="btn btn-primary" onclick="startGame()">Play Again</button>
            <button class="btn btn-secondary" onclick="window.location.href='../index.html'">Back to Home</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextCtx = nextCanvas.getContext('2d');
        const holdCanvas = document.getElementById('holdCanvas');
        const holdCtx = holdCanvas.getContext('2d');

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 30;
        const COLORS = {
            I: '#00f0ff',
            O: '#fbbf24',
            T: '#a855f7',
            S: '#4ade80',
            Z: '#ef4444',
            J: '#3b82f6',
            L: '#f97316'
        };

        const SHAPES = {
            I: [[1,1,1,1]],
            O: [[1,1],[1,1]],
            T: [[0,1,0],[1,1,1]],
            S: [[0,1,1],[1,1,0]],
            Z: [[1,1,0],[0,1,1]],
            J: [[1,0,0],[1,1,1]],
            L: [[0,0,1],[1,1,1]]
        };

        let board, currentPiece, nextPiece, holdPiece;
        let score, lines, level;
        let gameRunning, paused, canHold;
        let dropInterval, dropCounter;
        let synth, placeSynth, clearSynth, rotateSynth;

        function init() {
            // Initialize Tone.js
            synth = new Tone.Synth({ oscillator: { type: "triangle" }}).toDestination();
            placeSynth = new Tone.Synth({ oscillator: { type: "square" }}).toDestination();
            clearSynth = new Tone.Synth({ oscillator: { type: "sine" }}).toDestination();
            rotateSynth = new Tone.Synth({ oscillator: { type: "triangle" }}).toDestination();

            document.addEventListener('keydown', handleKeyPress);
        }

        function startGame() {
            Tone.start();
            
            board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            score = 0;
            lines = 0;
            level = 1;
            canHold = true;
            gameRunning = true;
            paused = false;
            dropCounter = 0;
            
            nextPiece = createPiece();
            holdPiece = null;
            spawnPiece();
            
            document.getElementById('startBtn').disabled = true;
            document.getElementById('gameOverModal').classList.remove('active');
            
            clearCanvas(holdCtx, holdCanvas.width, holdCanvas.height);
            updateUI();
            gameLoop();
        }

        function createPiece() {
            const types = Object.keys(SHAPES);
            const type = types[Math.floor(Math.random() * types.length)];
            return {
                type,
                shape: JSON.parse(JSON.stringify(SHAPES[type])),
                color: COLORS[type],
                x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
                y: 0
            };
        }

        function spawnPiece() {
            currentPiece = nextPiece;
            nextPiece = createPiece();
            canHold = true;
            
            if (!isValidMove(currentPiece, 0, 0)) {
                endGame();
            }
            
            drawNext();
        }

        function rotatePiece() {
            const rotated = currentPiece.shape[0].map((_, i) => 
                currentPiece.shape.map(row => row[i]).reverse()
            );
            
            const backup = currentPiece.shape;
            currentPiece.shape = rotated;
            
            if (!isValidMove(currentPiece, 0, 0)) {
                currentPiece.shape = backup;
            } else {
                rotateSynth.triggerAttackRelease("G5", "32n");
            }
        }

        function isValidMove(piece, offsetX, offsetY) {
            for (let y = 0; y < piece.shape.length; y++) {
                for (let x = 0; x < piece.shape[y].length; x++) {
                    if (piece.shape[y][x]) {
                        const newX = piece.x + x + offsetX;
                        const newY = piece.y + y + offsetY;
                        
                        if (newX < 0 || newX >= COLS || newY >= ROWS) return false;
                        if (newY >= 0 && board[newY][newX]) return false;
                    }
                }
            }
            return true;
        }

        function mergePiece() {
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        const boardY = currentPiece.y + y;
                        const boardX = currentPiece.x + x;
                        if (boardY >= 0) {
                            board[boardY][boardX] = currentPiece.color;
                        }
                    }
                });
            });
            
            placeSynth.triggerAttackRelease("C3", "32n");
            clearLines();
            spawnPiece();
        }

        function clearLines() {
            let linesCleared = 0;
            
            for (let y = ROWS - 1; y >= 0; y--) {
                if (board[y].every(cell => cell !== 0)) {
                    board.splice(y, 1);
                    board.unshift(Array(COLS).fill(0));
                    linesCleared++;
                    y++;
                    
                    // Particle effect
                    createLineClearEffect(y);
                }
            }
            
            if (linesCleared > 0) {
                lines += linesCleared;
                score += [0, 100, 300, 500, 800][linesCleared] * level;
                level = Math.floor(lines / 10) + 1;
                
                clearSynth.triggerAttackRelease("C6", "16n");
                setTimeout(() => clearSynth.triggerAttackRelease("E6", "16n"), 100);
                
                updateUI();
            }
        }

        function createLineClearEffect(row) {
            // Visual effect on canvas
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.fillRect(0, row * BLOCK_SIZE, canvas.width, BLOCK_SIZE);
        }

        function holdCurrentPiece() {
            if (!canHold) return;
            
            if (holdPiece === null) {
                holdPiece = createPiece();
                holdPiece.type = currentPiece.type;
                holdPiece.shape = JSON.parse(JSON.stringify(SHAPES[currentPiece.type]));
                holdPiece.color = currentPiece.color;
                spawnPiece();
            } else {
                const temp = holdPiece;
                holdPiece = createPiece();
                holdPiece.type = currentPiece.type;
                holdPiece.shape = JSON.parse(JSON.stringify(SHAPES[currentPiece.type]));
                holdPiece.color = currentPiece.color;
                
                currentPiece = temp;
                currentPiece.x = Math.floor(COLS / 2) - Math.floor(currentPiece.shape[0].length / 2);
                currentPiece.y = 0;
            }
            
            canHold = false;
            drawHold();
            synth.triggerAttackRelease("A4", "32n");
        }

        function hardDrop() {
            while (isValidMove(currentPiece, 0, 1)) {
                currentPiece.y++;
                score += 2;
            }
            mergePiece();
            updateUI();
        }

        function handleKeyPress(e) {
            if (!gameRunning || paused) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    if (isValidMove(currentPiece, -1, 0)) currentPiece.x--;
                    break;
                case 'ArrowRight':
                    if (isValidMove(currentPiece, 1, 0)) currentPiece.x++;
                    break;
                case 'ArrowDown':
                    if (isValidMove(currentPiece, 0, 1)) {
                        currentPiece.y++;
                        score++;
                        updateUI();
                    }
                    break;
                case 'ArrowUp':
                    rotatePiece();
                    break;
                case ' ':
                    e.preventDefault();
                    hardDrop();
                    break;
                case 'c':
                case 'C':
                    holdCurrentPiece();
                    break;
            }
        }

        function gameLoop() {
            if (!gameRunning) return;
            
            dropCounter++;
            const dropSpeed = Math.max(5, 60 - (level * 5));
            
            if (dropCounter >= dropSpeed) {
                if (isValidMove(currentPiece, 0, 1)) {
                    currentPiece.y++;
                } else {
                    mergePiece();
                }
                dropCounter = 0;
            }
            
            draw();
            requestAnimationFrame(gameLoop);
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.1)';
            for (let x = 0; x < COLS; x++) {
                ctx.beginPath();
                ctx.moveTo(x * BLOCK_SIZE, 0);
                ctx.lineTo(x * BLOCK_SIZE, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < ROWS; y++) {
                ctx.beginPath();
                ctx.moveTo(0, y * BLOCK_SIZE);
                ctx.lineTo(canvas.width, y * BLOCK_SIZE);
                ctx.stroke();
            }
            
            // Draw board
            board.forEach((row, y) => {
                row.forEach((color, x) => {
                    if (color) {
                        drawBlock(ctx, x, y, color);
                    }
                });
            });
            
            // Draw ghost piece
            const ghost = { ...currentPiece };
            while (isValidMove(ghost, 0, 1)) ghost.y++;
            ctx.globalAlpha = 0.3;
            ghost.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        drawBlock(ctx, ghost.x + x, ghost.y + y, ghost.color);
                    }
                });
            });
            ctx.globalAlpha = 1;
            
            // Draw current piece
            currentPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        drawBlock(ctx, currentPiece.x + x, currentPiece.y + y, currentPiece.color);
                    }
                });
            });
        }

        function drawBlock(context, x, y, color) {
            context.fillStyle = color;
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, BLOCK_SIZE - 1);
            
            // Highlight
            context.fillStyle = 'rgba(255, 255, 255, 0.3)';
            context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE - 1, 5);
        }

        function drawNext() {
            clearCanvas(nextCtx, nextCanvas.width, nextCanvas.height);
            const offsetX = (nextCanvas.width - nextPiece.shape[0].length * 20) / 2;
            const offsetY = (nextCanvas.height - nextPiece.shape.length * 20) / 2;
            
            nextPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        nextCtx.fillStyle = nextPiece.color;
                        nextCtx.fillRect(offsetX + x * 20, offsetY + y * 20, 19, 19);
                    }
                });
            });
        }

        function drawHold() {
            clearCanvas(holdCtx, holdCanvas.width, holdCanvas.height);
            if (!holdPiece) return;
            
            const offsetX = (holdCanvas.width - holdPiece.shape[0].length * 20) / 2;
            const offsetY = (holdCanvas.height - holdPiece.shape.length * 20) / 2;
            
            holdPiece.shape.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value) {
                        holdCtx.fillStyle = holdPiece.color;
                        holdCtx.fillRect(offsetX + x * 20, offsetY + y * 20, 19, 19);
                    }
                });
            });
        }

        function clearCanvas(context, width, height) {
            context.fillStyle = '#000';
            context.fillRect(0, 0, width, height);
        }

        function updateUI() {
            document.getElementById('score').textContent = score;
            document.getElementById('lines').textContent = lines;
            document.getElementById('level').textContent = level;
        }

        function endGame() {
            gameRunning = false;
            
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLines').textContent = lines;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('gameOverModal').classList.add('active');
            document.getElementById('startBtn').disabled = false;
        }

        init();
    </script>
</body>
</html>
